<!DOCTYPE html>
<html lang="ko">
<head>
    <meta name="color-scheme" content="dark light">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Focus Heatmap</title>
    
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=Playfair+Display:wght@400;600;700&family=Roboto+Mono:wght@400;500;700&display=swap');

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: transparent;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        /* 고정 사이즈 컨테이너 */
        .widget-container {
            position: relative;
            width: 95px; 
            height: 120px;
            background: linear-gradient(180deg, rgba(224, 242, 254, 0.2) 0%, rgba(240, 249, 255, 0.1) 100%);
            backdrop-filter: blur(20px);
            border-radius: 20px; /* 둥근 모서리 살짝 축소 */
            border: 1px solid rgba(224, 242, 254, 0.3);
            box-shadow: 0 0 20px rgba(186, 230, 253, 0.1), inset 0 0 10px rgba(224, 242, 254, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            color: #e0f2fe;
        }

        .font-serif { font-family: 'Playfair Display', serif; font-weight: 700; }
        .font-mono { font-family: 'Roboto Mono', monospace; }
        
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px; /* 간격 축소 */
            text-align: center;
            padding: 0 10px;
        }
        
        .day-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            font-size: 8px; /* 폰트 사이즈 축소 */
            font-family: 'Roboto Mono', monospace;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        /* Heatmap Colors (글자색 color 속성 제거됨) */
        .heat-0 { background: rgba(255, 255, 255, 0.03); color: #64748b; }
        
        /* [Level 1] 1시간 ~ 3시간 (연노랑: #fef08a) */
        .heat-1 { 
            background: rgba(254, 240, 138, 0.45); /* 연노랑 반투명 */
            border: 0.5px solid rgba(254, 240, 138, 0.2); 
        }
        
        /* [Level 2] 3시간 ~ 5시간 (스카이블루: #7dd3fc) */
        .heat-2 { 
            background: rgba(125, 211, 252, 0.6); /* 스카이블루 반투명 */
            box-shadow: 0 0 6px rgba(125, 211, 252, 0.4); /* 은은한 발광 효과 */
            border: 0.5px solid rgba(125, 211, 252, 0.4); 
        }
        
        .heat-3 { 
            background: rgba(192, 132, 252, 0.7); 
            box-shadow: 0 0 6px rgba(192, 132, 252, 0.4); 
            font-weight: 700; 
            border: 0.5px solid rgba(216, 180, 254, 0.4); 
        }
        .day-today {
            border: 1px solid #ffffff !important;
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.4);
            z-index: 10;
        }

        .nav-btn { width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; border-radius: 4px; color: rgba(255, 255, 255, 0.5); transition: all 0.2s; }
        .nav-btn:hover { color: white; background: rgba(255,255,255,0.1); }
        
        .tooltip {
            position: absolute;
            bottom: 15px; /* 위쪽으로 띄움 */
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 9px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 20;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .day-cell:hover .tooltip { opacity: 1; }

    </style>
</head>
<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const Icons = {
            ChevronLeft: () => <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="4" strokeLinecap="round" strokeLinejoin="round"><path d="M15 18l-6-6 6-6"/></svg>,
            ChevronRight: () => <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="4" strokeLinecap="round" strokeLinejoin="round"><path d="M9 18l6-6-6-6"/></svg>,
            RotateCcw: () => <svg width="9" height="9" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>,
            Flame: () => <svg width="9" height="9" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.1.2-2.2.6-3.3a7 7 0 0 0 3 3.3z"></path></svg>,
        };

        const App = () => {
            const [currentDate, setCurrentDate] = useState(new Date()); 
            const [focusData, setFocusData] = useState({}); 
            const [monthTotal, setMonthTotal] = useState(0);

            // [수정] 서버 주소 (Daily_Log와 동일하게 설정)
            const WORKER_URL = "https://log-worker.moonkelly601.workers.dev";
            
            // [수정] Total(숫자) 값을 최우선으로 사용하여 정확도 100% 보장 + 안전장치 적용
            const loadData = async () => {
                const map = {};
                const formatYMD = (y, m, d) => `${y}-${String(m).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
                
                // [헬퍼] 텍스트 시간 포맷 파싱
                const parseTimeStr = (str) => {
                    if (!str) return 0;
                    let min = 0;
                    const hMatch = str.match(/(\d+)\s*[Hh]/);
                    const mMatch = str.match(/(\d+)\s*[Mm]/);
                    if (hMatch) min += parseInt(hMatch[1]) * 60;
                    if (mMatch) min += parseInt(mMatch[1]);
                    return min;
                };

                // [헬퍼] 데이터 추출 (Total 우선)
                const extractMinutes = (data) => {
                    if (!data) return 0;
                    if (typeof data.Total === 'number') return data.Total;
                    if (typeof data.total === 'number') return data.total;
                    if (data.Total && !isNaN(data.Total)) return Number(data.Total);
                    if (data.total && !isNaN(data.total)) return Number(data.total);

                    let total = 0;
                    const blocks = Array.isArray(data) ? data : (data.blocks || []);
                    if (blocks.length > 0) {
                        total += blocks
                            .filter(b => b.type === 'focus' || !b.type)
                            .reduce((acc, cur) => acc + (cur.duration || 0), 0);
                    }
                    if (data.taskLog && typeof data.taskLog === 'string') {
                        const lines = data.taskLog.split('\n');
                        let logMinutes = 0;
                        lines.forEach(line => {
                            const timeMatch = line.match(/\(([^)]+)\)\s*$/); 
                            if (timeMatch) logMinutes += parseTimeStr(timeMatch[1]);
                        });
                        if (logMinutes > total) total = logMinutes;
                    }
                    return total;
                };

                // 1. 로컬 데이터 로드
                try {
                    const history = JSON.parse(localStorage.getItem('fortressHistory') || '[]');
                    history.forEach(day => {
                        if (day.date) {
                            const d = new Date(day.date);
                            map[formatYMD(d.getFullYear(), d.getMonth() + 1, d.getDate())] = extractMinutes(day);
                        }
                    });
                    const todayData = JSON.parse(localStorage.getItem('fortressData') || '{}');
                    if (todayData.date) {
                        const d = new Date(todayData.date);
                        map[formatYMD(d.getFullYear(), d.getMonth() + 1, d.getDate())] = extractMinutes(todayData);
                    }
                } catch (e) { console.error("Local Load Error", e); }

                // 2. 서버 데이터 가져오기
                try {
                    const year = currentDate.getFullYear();
                    const month = currentDate.getMonth() + 1;
                    const daysInMonth = new Date(year, month, 0).getDate();
                    
                    const datesToFetch = [];
                    for (let d = 1; d <= daysInMonth; d++) {
                        datesToFetch.push(formatYMD(year, month, d));
                    }

                    const BATCH_SIZE = 3;
                    for (let i = 0; i < datesToFetch.length; i += BATCH_SIZE) {
                        const batch = datesToFetch.slice(i, i + BATCH_SIZE);
                        
                        await Promise.all(batch.map(async (dateKey) => {
                            try {
                                const res = await fetch(`${WORKER_URL}?date=${dateKey}`);
                                if (res.ok) {
                                    const data = await res.json();
                                    const minutes = extractMinutes(data);
                                    if (minutes > 0) map[dateKey] = minutes;
                                }
                            } catch (err) { }
                        }));
                        
                        await new Promise(r => setTimeout(r, 300)); 

                        // [중간 업데이트] 안전장치 적용
                        setFocusData(prev => {
                            const merged = { ...prev };
                            Object.keys(map).forEach(key => {
                                const newVal = map[key];
                                const oldVal = prev[key] || 0;
                                if (newVal >= oldVal) merged[key] = newVal;
                            });
                            return merged;
                        });
                    }
                } catch (e) { console.warn("Server sync failed", e); }

                // [최종 업데이트] 안전장치 적용
                setFocusData(prev => {
                    const merged = { ...prev };
                    Object.keys(map).forEach(key => {
                        const newVal = map[key];
                        const oldVal = prev[key] || 0;
                        if (newVal >= oldVal) merged[key] = newVal;
                    });
                    return merged;
                });
            };

            const prevMonth = () => setCurrentDate(new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1));
            const nextMonth = () => setCurrentDate(new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1));
            const goToday = () => setCurrentDate(new Date());

            const year = currentDate.getFullYear();
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const monthStr = monthNames[currentDate.getMonth()];

            const firstDayOfMonth = new Date(year, currentDate.getMonth(), 1);
            const daysInMonth = new Date(year, currentDate.getMonth() + 1, 0).getDate();
            const startDay = firstDayOfMonth.getDay();

            const prevMonthLastDate = new Date(year, currentDate.getMonth(), 0).getDate();

            const getHeatClass = (minutes) => {
                if (!minutes || minutes < 60) return 'heat-0';
                if (minutes <= 180) return 'heat-1';
                if (minutes <= 300) return 'heat-2';
                return 'heat-3';
            };

            const formatTime = (min) => {
                const h = Math.floor(min / 60);
                const m = min % 60;
                return h > 0 ? `${h}H ${m}M` : `${m}M`;
            };

            return (
                <div className="widget-container">
                    {/* Compact Header: 버튼 좌측 정렬 (justify-start + px-3) */}
                    <div className="w-full flex justify-start items-center border-b border-white/5 bg-white/5 backdrop-blur-sm shrink-0 h-[28px] px-2">
                        <div className="flex gap-0 -space-x-1 items-center">
                            <button onClick={goToday} className="nav-btn mr-1 z-10" title="Go Today"><Icons.RotateCcw /></button>
                            <button onClick={prevMonth} className="nav-btn"><Icons.ChevronLeft /></button>
                            <button onClick={nextMonth} className="nav-btn"><Icons.ChevronRight /></button>
                        </div>
                    </div>

                    {/* Calendar Grid */}
                    <div className="flex-1 flex flex-col justify-center pb-5">
                    <div className="calendar-grid mb-0.5 mt-2">
                            {['S','M','T','W','T','F','S'].map((d, i) => (
                                <div key={i} className={`text-[7px] font-bold ${i === 0 ? 'text-rose-300' : (i === 6 ? 'text-blue-300' : 'text-slate-500')}`}>{d}</div>
                            ))}
                        </div>
                        <div className="calendar-grid">
                            {Array.from({length: 35}).map((_, i) => { // 35칸(5줄)로 고정
                                const dayNumber = i - startDay + 1;
                                
                                // 현재 달의 날짜인지 판별
                                const isCurrentMonth = dayNumber > 0 && dayNumber <= daysInMonth;
                                
                                // 표시할 날짜 계산: 현재 달이면 그대로, 아니면(앞쪽 빈칸) 지난달 날짜 계산
                                const displayDay = isCurrentMonth ? dayNumber : (dayNumber <= 0 ? prevMonthLastDate + dayNumber : null);

                                // 뒷쪽 빈칸(다음달)은 그냥 숨김 처리
                                if (!displayDay) return <div key={i} className="day-cell opacity-0 pointer-events-none"></div>;

                                // 데이터 조회용 날짜 객체 생성 (이전 달 날짜인 경우 달을 -1 처리)
                                const targetDate = new Date(year, currentDate.getMonth() + (isCurrentMonth ? 0 : -1), displayDay);
                                const dateKey = `${targetDate.getFullYear()}-${String(targetDate.getMonth() + 1).padStart(2, '0')}-${String(targetDate.getDate()).padStart(2, '0')}`;
                                
                                const minutes = focusData[dateKey] || 0;
                                const heatClass = getHeatClass(minutes);
                                
                                // 오늘 날짜인지 확인
                                const today = new Date();
                                const isToday = today.toDateString() === targetDate.toDateString();

                                return (
                                    <div key={i} className={`day-cell ${heatClass} ${isToday ? 'day-today' : ''} ${!isCurrentMonth ? 'opacity-40 saturate-0' : ''}`}>
                                        {minutes > 0 && (
                                            <div className="tooltip">
                                                {formatTime(minutes)}
                                            </div>
                                        )}
                                    </div>
                                )
                            })}
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
