<!DOCTYPE html>
<html lang="ko">
<head>
    <meta name="color-scheme" content="dark light">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Focus Heatmap</title>
    
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=Playfair+Display:wght@400;600;700&family=Roboto+Mono:wght@400;500;700&display=swap');

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: transparent;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        /* 고정 사이즈 컨테이너 */
        .widget-container {
            position: relative;
            width: 120px; 
            height: 120px;
            background: linear-gradient(180deg, rgba(224, 242, 254, 0.2) 0%, rgba(240, 249, 255, 0.1) 100%);
            backdrop-filter: blur(20px);
            border-radius: 20px; /* 둥근 모서리 살짝 축소 */
            border: 1px solid rgba(224, 242, 254, 0.3);
            box-shadow: 0 0 20px rgba(186, 230, 253, 0.1), inset 0 0 10px rgba(224, 242, 254, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            color: #e0f2fe;
        }

        .font-serif { font-family: 'Playfair Display', serif; font-weight: 700; }
        .font-mono { font-family: 'Roboto Mono', monospace; }
        
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px; /* 1px -> 2px : 박스 사이 틈을 벌려서 여유 확보 */
            text-align: center;
            padding: 0 12px; /* 8px -> 12px : 양옆을 더 눌러서 박스 크기 축소 */
            margin-top: 0px;
        }
        
        .day-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 1.5px; /* 모서리 둥글기를 Block 위젯과 유사하게 축소 */
            font-size: 8px;
            font-family: 'Roboto Mono', monospace;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        /* Heatmap Colors (글자색 color 속성 제거됨) */
        .heat-0 { background: rgba(255, 255, 255, 0.03); color: #64748b; }

        .heat-start { 
            background: rgba(148, 163, 184, 0.3); 
            border: 0.5px solid rgba(148, 163, 184, 0.2);
        }
        
        /* [Level 1] 1시간 ~ 3시간 (연노랑: #fef08a) */
        .heat-1 { 
            background: rgba(254, 240, 138, 0.45); /* 연노랑 반투명 */
            border: 0.5px solid rgba(254, 240, 138, 0.2); 
        }
        
        /* [Level 2] 3시간 ~ 5시간 (스카이블루: #7dd3fc) */
        .heat-2 { 
            background: rgba(125, 211, 252, 0.6); /* 스카이블루 반투명 */
            border: 0.5px solid rgba(125, 211, 252, 0.4); 
        }
        
        .heat-3 { 
            background: rgba(216, 180, 254, 0.7); /* 기존(192,132,252) -> 변경(216,180,254) */
            font-weight: 700; 
            border: 0.5px solid rgba(216, 180, 254, 0.4); 
        }
        
        .day-today {
            border: 1px solid #ffffff !important;
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.4);
            z-index: 10;
        }

        .nav-btn { width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; border-radius: 4px; color: rgba(255, 255, 255, 0.5); transition: all 0.2s; }
        .nav-btn:hover { color: white; background: rgba(255,255,255,0.1); }
        
        .tooltip {
            position: absolute;
            bottom: 15px; /* 위쪽으로 띄움 */
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 9px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 20;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .day-cell:hover .tooltip { opacity: 1; }

    </style>
</head>
<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const Icons = {
            ChevronLeft: () => <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="4" strokeLinecap="round" strokeLinejoin="round"><path d="M15 18l-6-6 6-6"/></svg>,
            ChevronRight: () => <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="4" strokeLinecap="round" strokeLinejoin="round"><path d="M9 18l6-6-6-6"/></svg>,
            RotateCcw: () => <svg width="9" height="9" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>,
            Flame: () => <svg width="9" height="9" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.1.2-2.2.6-3.3a7 7 0 0 0 3 3.3z"></path></svg>,
        };

        const App = () => {
            const [currentDate, setCurrentDate] = useState(new Date()); 
            const [focusData, setFocusData] = useState({}); 
            
            /* [추가/수정] 해당 월의 총 집중시간 계산 (useMemo 활용) */
const currentMonthTotal = React.useMemo(() => {
    let total = 0;
    const y = currentDate.getFullYear();
    const m = currentDate.getMonth() + 1;
    
    // focusData에서 현재 보고 있는 달(y-m)에 해당하는 날짜만 합산
    Object.keys(focusData).forEach(key => {
        const [dy, dm, dd] = key.split('-').map(Number);
        if (dy === y && dm === m) {
            total += focusData[key];
        }
    });
    return total;
}, [focusData, currentDate]);

/* [추가] 시간 포맷팅 함수 (분 -> 시간) */
const formatTotalTime = (min) => {
    const h = Math.floor(min / 60);
    // 공간이 좁으므로 분 단위는 반올림하거나 생략하고 '45H' 처럼 심플하게 가거나
    // '45.5H' 처럼 소수점 한자리로 표현하는 게 깔끔함. 여기선 깔끔하게 시간만 강조.
    return `${h}H`; 
    // 만약 분까지 필요하면: const m = min % 60; return `${h}h ${m}m`;
};

            // [수정] 서버 주소 (Daily_Log와 동일하게 설정)
            const WORKER_URL = "https://log-worker.moonkelly601.workers.dev";
            
            // [수정] 속도 개선 및 데이터 파싱 강화
            const loadData = async () => {
                const map = {};
                const formatYMD = (y, m, d) => `${y}-${String(m).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
                
                /// [추가] 시간 문자열 파싱 함수
                const parseTimeStr = (str) => {
                    if (!str) return 0;
                    let total = 0;
                    const hMatch = str.match(/(\d+)\s*H/i);
                    const mMatch = str.match(/(\d+)\s*M/i);
                    if (hMatch) total += parseInt(hMatch[1]) * 60;
                    if (mMatch) total += parseInt(mMatch[1]);
                    return total;
                };

                // 숫자를 확실하게 추출하는 함수 (노션 원본 데이터 구조까지 대응)
                const extractMinutes = (data) => {
                    
                    if (!data) return 0;
                    
                    // 1. 가장 깔끔한 경우 (Total이 바로 숫자로 있을 때)
                    if (typeof data.Total === 'number') return data.Total;
                    if (typeof data.total === 'number') return data.total;

                    // 2. 문자열로 들어온 경우 ("203" 등)
                    if (data.Total && !isNaN(data.Total)) return Number(data.Total);
                    
                    // 3. 노션 원본 구조 (properties -> Total -> number)
                    if (data.properties?.Total?.number) return data.properties.Total.number;

                    // 4. 그래도 없으면 기존 방식 (blocks 합산 등)
                    let total = 0;
                    
                    const blocks = Array.isArray(data) ? data : (data.blocks || []);
                    if (blocks.length > 0) {
                        total += blocks
                            .filter(b => b.type === 'focus' || !b.type)
                            .reduce((acc, cur) => acc + (cur.duration || 0), 0);
                    }
                    if (data.taskLog && typeof data.taskLog === 'string') {
                        const lines = data.taskLog.split('\n');
                        let logMinutes = 0;
                        lines.forEach(line => {
                            const timeMatch = line.match(/\(([^)]+)\)\s*$/); 
                            if (timeMatch) logMinutes += parseTimeStr(timeMatch[1]);
                        });
                        if (logMinutes > total) total = logMinutes;
                    }
                    return total;
                };

                // 1. 로컬 데이터 로드
                try {
                    const history = JSON.parse(localStorage.getItem('fortressHistory') || '[]');
                    history.forEach(day => {
                        if (day.date) {
                            const d = new Date(day.date);
                            map[formatYMD(d.getFullYear(), d.getMonth() + 1, d.getDate())] = extractMinutes(day);
                        }
                    });
                    
                    const todayData = JSON.parse(localStorage.getItem('fortressData') || '{}');
                    if (todayData.date) {
                        const d = new Date(todayData.date);
                        map[formatYMD(d.getFullYear(), d.getMonth() + 1, d.getDate())] = extractMinutes(todayData);
                    }
                } catch (e) { console.error("Local Load Error", e); }

                // 2. 서버 데이터 가져오기 (고속 모드)
                try {
                    const year = currentDate.getFullYear();
                    const month = currentDate.getMonth() + 1;
                    const daysInMonth = new Date(year, month, 0).getDate();
                    
                    const datesToFetch = [];
                    for (let d = 1; d <= daysInMonth; d++) {
                        datesToFetch.push(formatYMD(year, month, d));
                    }

                    // [변경] 한 번에 10일치씩 요청, 딜레이 제거
                    const BATCH_SIZE = 10; 
                    
                    for (let i = 0; i < datesToFetch.length; i += BATCH_SIZE) {
                        const batch = datesToFetch.slice(i, i + BATCH_SIZE);
                        
                        await Promise.all(batch.map(async (dateKey) => {
                            try {
                                const res = await fetch(`${WORKER_URL}?date=${dateKey}`);
                                if (res.ok) {
                                    const data = await res.json();
                                    const minutes = extractMinutes(data);
                                    if (minutes > 0) {
                                        map[dateKey] = minutes;
                                    }
                                    // [추가] 서버가 0을 줬어도 기존 값이 있으면 유지
                                }
                            } catch (err) {
                                console.warn(`Failed: ${dateKey}`, err);
                            }
                        }));
                        
                        // [수정] 기존 값 보존하면서 새 값만 덮어쓰기
                        setFocusData(prev => {
                            const merged = { ...prev };
                            Object.keys(map).forEach(key => {
                                // 새 값이 있을 때만 업데이트 (0이면 기존 값 유지)
                                if (map[key] > 0) {
                                    merged[key] = map[key];
                                }
                            });
                            return merged;
                        });
                    } 
                } catch (e) { 
                    console.error("Server Load Error", e); 
                }
            };

            useEffect(() => {
                loadData();
                
                // 다른 탭에서 데이터 변경 시 갱신
                const handleStorage = (e) => {
                    if (e.key === 'fortressData' || e.key === 'fortressHistory') {
                        loadData();
                    }
                };
                window.addEventListener('storage', handleStorage);
                
                // 같은 탭용 주기적 갱신 (30초)
                const interval = setInterval(loadData, 30000);
                
                return () => {
                    window.removeEventListener('storage', handleStorage);
                    clearInterval(interval);
                };
            }, [currentDate]);
            
            const prevMonth = () => setCurrentDate(new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1));
            const nextMonth = () => setCurrentDate(new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1));
            const goToday = () => setCurrentDate(new Date());

            const year = currentDate.getFullYear();
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const monthStr = monthNames[currentDate.getMonth()];

            const firstDayOfMonth = new Date(year, currentDate.getMonth(), 1);
            const daysInMonth = new Date(year, currentDate.getMonth() + 1, 0).getDate();
            const startDay = firstDayOfMonth.getDay();

            const prevMonthLastDate = new Date(year, currentDate.getMonth(), 0).getDate();

            const getHeatClass = (minutes) => {
    // 1. [30분 이하] 아주 짧은 시간은 빈칸 처리
    if (!minutes || minutes <= 30) return 'heat-0'; 
    
    // 2. [31분 ~ 2시간 미만] 예열 단계 -> 회색 (추가된 구간)
    if (minutes < 120) return 'heat-start'; 
    
    // 3. [2시간 ~ 4시간] 몰입 초기 -> 연노랑
    if (minutes <= 240) return 'heat-1'; 
    
    // 4. [4시간 ~ 6시간] 몰입 안정 -> 스카이블루
    if (minutes <= 360) return 'heat-2'; 
    
    // 5. [6시간 초과] 딥 워크 -> 연보라
    return 'heat-3'; 
};

            const formatTime = (min) => {
                const h = Math.floor(min / 60);
                const m = min % 60;
                return h > 0 ? `${h}H ${m}M` : `${m}M`;
            };

            return (
                <div className="widget-container">
                    {/* Compact Header: 월 이동 기능을 포함한 중앙 텍스트 */}
<div className="w-full flex justify-between items-center border-b border-white/5 bg-white/5 backdrop-blur-sm shrink-0 h-[28px] px-1 relative">
    
    {/* 왼쪽 투명 버튼 (이전 달) */}
    <button onClick={prevMonth} className="h-full px-2 z-10 text-transparent hover:text-white/20 transition-colors absolute left-0 flex items-center">
        <Icons.ChevronLeft />
    </button>

    {/* 중앙 텍스트 (이번 달 총 누적 시간) */}
    <div className="w-full text-center flex items-baseline justify-center gap-1.5 cursor-default z-0">
        <span className="text-[10px] text-slate-400 font-mono tracking-tighter uppercase">
            {monthStr} Total
        </span>
        <span className="text-[11px] font-bold text-slate-200 font-mono tracking-tight">
            {formatTotalTime(currentMonthTotal)}
        </span>
    </div>

    {/* 오른쪽 투명 버튼 (다음 달) - 오늘로 가는 버튼은 공간 부족으로 생략하거나 타이틀 클릭으로 변경 고려 */}
    <button onClick={nextMonth} className="h-full px-2 z-10 text-transparent hover:text-white/20 transition-colors absolute right-0 flex items-center">
        <Icons.ChevronRight />
    </button>
</div>

                    {/* Calendar Grid */}
                    <div className="flex-1 flex flex-col justify-start pt-1">
                    {/* mt-1 제거, mb-1을 0.5로 축소 */}
                    <div className="calendar-grid mb-0.5 mt-0">
                            {['S','M','T','W','T','F','S'].map((d, i) => (
                                <div key={i} className={`text-[7px] font-bold ${i === 0 ? 'text-rose-300' : (i === 6 ? 'text-blue-300' : 'text-slate-500')}`}>{d}</div>
                            ))}
                        </div>
                        <div className="calendar-grid">
                            {Array.from({length: 35}).map((_, i) => { // 35칸(5줄)로 고정
                                const dayNumber = i - startDay + 1;
                                
                                // 현재 달의 날짜인지 판별
                                const isCurrentMonth = dayNumber > 0 && dayNumber <= daysInMonth;
                                
                                // 표시할 날짜 계산: 현재 달이면 그대로, 아니면(앞쪽 빈칸) 지난달 날짜 계산
                                const displayDay = isCurrentMonth ? dayNumber : (dayNumber <= 0 ? prevMonthLastDate + dayNumber : null);

                                // 뒷쪽 빈칸(다음달)은 그냥 숨김 처리
                                if (!displayDay) return <div key={i} className="day-cell opacity-0 pointer-events-none"></div>;

                                // 데이터 조회용 날짜 객체 생성 (이전 달 날짜인 경우 달을 -1 처리)
                                const targetDate = new Date(year, currentDate.getMonth() + (isCurrentMonth ? 0 : -1), displayDay);
                                const dateKey = `${targetDate.getFullYear()}-${String(targetDate.getMonth() + 1).padStart(2, '0')}-${String(targetDate.getDate()).padStart(2, '0')}`;
                                
                                const minutes = focusData[dateKey] || 0;
                                const heatClass = getHeatClass(minutes);
                                
                                // 오늘 날짜인지 확인
                                const today = new Date();
                                const isToday = today.toDateString() === targetDate.toDateString();

                                return (
                                    <div key={i} className={`day-cell ${heatClass} ${isToday ? 'day-today' : ''} ${!isCurrentMonth ? 'opacity-40 saturate-0' : ''}`}>
                                        {minutes > 0 && (
                                            <div className="tooltip">
                                                {formatTime(minutes)}
                                            </div>
                                        )}
                                    </div>
                                )
                            })}
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
