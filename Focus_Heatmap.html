<!DOCTYPE html>
<html lang="ko">
<head>
    <meta name="color-scheme" content="dark light">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Focus Heatmap</title>
    
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=Playfair+Display:wght@400;600;700&family=Roboto+Mono:wght@400;500;700&display=swap');

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: transparent;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        /* 고정 사이즈 컨테이너 */
        .widget-container {
            position: relative;
            width: 95px; 
            height: 120px;
            background: linear-gradient(180deg, rgba(224, 242, 254, 0.2) 0%, rgba(240, 249, 255, 0.1) 100%);
            backdrop-filter: blur(20px);
            border-radius: 20px; /* 둥근 모서리 살짝 축소 */
            border: 1px solid rgba(224, 242, 254, 0.3);
            box-shadow: 0 0 20px rgba(186, 230, 253, 0.1), inset 0 0 10px rgba(224, 242, 254, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            color: #e0f2fe;
        }

        .font-serif { font-family: 'Playfair Display', serif; font-weight: 700; }
        .font-mono { font-family: 'Roboto Mono', monospace; }
        
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px; /* 간격 축소 */
            text-align: center;
            padding: 0 10px;
        }
        
        .day-cell {
            height: 12px; /* 높이 대폭 축소 (124px에 맞추기 위함) */
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            font-size: 8px; /* 폰트 사이즈 축소 */
            font-family: 'Roboto Mono', monospace;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        /* Heatmap Colors (글자색 color 속성 제거됨) */
        .heat-0 { background: rgba(255, 255, 255, 0.03); color: #64748b; }
        
        .heat-1 { 
            background: rgba(125, 211, 252, 0.3); 
            border: 0.5px solid rgba(125, 211, 252, 0.1); 
        }
        
        .heat-2 { 
            background: rgba(14, 165, 233, 0.6); 
            box-shadow: 0 0 4px rgba(14, 165, 233, 0.3); 
            border: 0.5px solid rgba(125, 211, 252, 0.3); 
        }
        
        .heat-3 { 
            background: rgba(192, 132, 252, 0.7); 
            box-shadow: 0 0 6px rgba(192, 132, 252, 0.4); 
            font-weight: 700; 
            border: 0.5px solid rgba(216, 180, 254, 0.4); 
        }
        .day-today {
            border: 1px solid #ffffff !important;
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.4);
            z-index: 10;
        }

        .nav-btn { width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; border-radius: 4px; color: rgba(255, 255, 255, 0.5); transition: all 0.2s; }
        .nav-btn:hover { color: white; background: rgba(255,255,255,0.1); }
        
        .tooltip {
            position: absolute;
            bottom: 15px; /* 위쪽으로 띄움 */
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 9px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 20;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .day-cell:hover .tooltip { opacity: 1; }

    </style>
</head>
<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const Icons = {
            ChevronLeft: () => <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="4" strokeLinecap="round" strokeLinejoin="round"><path d="M15 18l-6-6 6-6"/></svg>,
            ChevronRight: () => <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="4" strokeLinecap="round" strokeLinejoin="round"><path d="M9 18l6-6-6-6"/></svg>,
            RotateCcw: () => <svg width="9" height="9" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>,
            Flame: () => <svg width="9" height="9" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.1.2-2.2.6-3.3a7 7 0 0 0 3 3.3z"></path></svg>,
        };

        const App = () => {
            const [currentDate, setCurrentDate] = useState(new Date()); 
            const [focusData, setFocusData] = useState({}); 
            const [monthTotal, setMonthTotal] = useState(0);

            // [수정] 서버 주소 추가
            const WORKER_URL = "https://log-worker.moonkelly601.workers.dev";

            // [수정] 서버 데이터 병렬 조회 (월간 데이터 완벽 복구)
            const loadData = async () => {
                const map = {};
                const formatYMD = (y, m, d) => `${y}-${String(m).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
                
                // 1. 로컬 데이터 우선 로드 (빠른 표시용)
                try {
                    const history = JSON.parse(localStorage.getItem('fortressHistory') || '[]');
                    history.forEach(day => {
                        if (day.date) {
                            const d = new Date(day.date);
                            const key = formatYMD(d.getFullYear(), d.getMonth() + 1, d.getDate());
                            const minutes = (day.blocks || []).filter(b => b.type === 'focus' || !b.type).reduce((acc, cur) => acc + (cur.duration || 0), 0);
                            map[key] = minutes;
                        }
                    });
                    
                    const todayData = JSON.parse(localStorage.getItem('fortressData') || '{}');
                    if (todayData.date) {
                        const d = new Date(todayData.date);
                        const key = formatYMD(d.getFullYear(), d.getMonth() + 1, d.getDate());
                        const minutes = (todayData.blocks || []).filter(b => b.type === 'focus' || !b.type).reduce((acc, cur) => acc + (cur.duration || 0), 0);
                        map[key] = minutes;
                    }
                } catch (e) {}

                // 2. 서버 데이터 전체 긁어오기 (현재 월 1일 ~ 말일)
                try {
                    const year = currentDate.getFullYear();
                    const month = currentDate.getMonth() + 1;
                    const daysInMonth = new Date(year, month, 0).getDate();
                    
                    const promises = [];
                    
                    // 1일부터 말일까지 모든 날짜에 대해 요청 생성
                    for (let d = 1; d <= daysInMonth; d++) {
                        const dateKey = formatYMD(year, month, d);
                        
                        // 서버 요청 (병렬 처리)
                        promises.push(
                            fetch(`${WORKER_URL}?date=${dateKey}`)
                                .then(res => res.ok ? res.json() : null)
                                .then(data => {
                                    if (data) {
                                        const blocks = Array.isArray(data) ? data : (data.blocks || []);
                                        if (blocks.length > 0) {
                                            const minutes = blocks
                                                .filter(b => b.type === 'focus' || !b.type)
                                                .reduce((acc, cur) => acc + (cur.duration || 0), 0);
                                            
                                            // 서버 데이터가 존재하면 맵에 기록 (덮어쓰기)
                                            if (minutes > 0) map[dateKey] = minutes;
                                        }
                                    }
                                })
                                .catch(() => {}) // 개별 실패는 무시하고 진행
                        );
                    }

                    // 모든 요청이 끝날 때까지 대기 후 화면 갱신
                    await Promise.all(promises);
                    
                } catch (e) { console.warn("Server sync failed", e); }

                setFocusData({ ...map });
            };

            useEffect(() => {
                loadData();
                window.addEventListener('storage', loadData);
                const interval = setInterval(loadData, 60000);
                return () => {
                    window.removeEventListener('storage', loadData);
                    clearInterval(interval);
                };
            }, []);

            useEffect(() => {
                const year = currentDate.getFullYear();
                const month = currentDate.getMonth() + 1;
                const prefix = `${year}-${String(month).padStart(2,'0')}`;
                let sum = 0;
                Object.keys(focusData).forEach(key => {
                    if (key.startsWith(prefix)) sum += focusData[key];
                });
                setMonthTotal(sum);
            }, [currentDate, focusData]);

            const prevMonth = () => setCurrentDate(new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1));
            const nextMonth = () => setCurrentDate(new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1));
            const goToday = () => setCurrentDate(new Date());

            const year = currentDate.getFullYear();
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const monthStr = monthNames[currentDate.getMonth()];

            const firstDayOfMonth = new Date(year, currentDate.getMonth(), 1);
            const daysInMonth = new Date(year, currentDate.getMonth() + 1, 0).getDate();
            const startDay = firstDayOfMonth.getDay();

            const prevMonthLastDate = new Date(year, currentDate.getMonth(), 0).getDate();

            const getHeatClass = (minutes) => {
                if (!minutes || minutes < 60) return 'heat-0';
                if (minutes <= 180) return 'heat-1';
                if (minutes <= 300) return 'heat-2';
                return 'heat-3';
            };

            const formatTime = (min) => {
                const h = Math.floor(min / 60);
                const m = min % 60;
                return h > 0 ? `${h}h${m}m` : `${m}m`;
            };

            return (
                <div className="widget-container">
                    {/* Compact Header: 버튼 좌측 정렬 (justify-start + px-3) */}
                    <div className="w-full flex justify-start items-center border-b border-white/5 bg-white/5 backdrop-blur-sm shrink-0 h-[28px] px-2">
                        <div className="flex gap-0 -space-x-1 items-center">
                            <button onClick={goToday} className="nav-btn mr-1 z-10" title="Go Today"><Icons.RotateCcw /></button>
                            <button onClick={prevMonth} className="nav-btn"><Icons.ChevronLeft /></button>
                            <button onClick={nextMonth} className="nav-btn"><Icons.ChevronRight /></button>
                        </div>
                    </div>

                    {/* Calendar Grid */}
                    <div className="flex-1 flex flex-col justify-center pb-0.5">
                        <div className="calendar-grid mb-0.5 mt-1">
                            {['S','M','T','W','T','F','S'].map((d, i) => (
                                <div key={i} className={`text-[7px] font-bold ${i === 0 ? 'text-rose-300' : (i === 6 ? 'text-blue-300' : 'text-slate-500')}`}>{d}</div>
                            ))}
                        </div>
                        <div className="calendar-grid">
                            {Array.from({length: 35}).map((_, i) => { // 35칸(5줄)로 고정
                                const dayNumber = i - startDay + 1;
                                
                                // 현재 달의 날짜인지 판별
                                const isCurrentMonth = dayNumber > 0 && dayNumber <= daysInMonth;
                                
                                // 표시할 날짜 계산: 현재 달이면 그대로, 아니면(앞쪽 빈칸) 지난달 날짜 계산
                                const displayDay = isCurrentMonth ? dayNumber : (dayNumber <= 0 ? prevMonthLastDate + dayNumber : null);

                                // 뒷쪽 빈칸(다음달)은 그냥 숨김 처리
                                if (!displayDay) return <div key={i} className="day-cell opacity-0 pointer-events-none"></div>;

                                // 데이터 조회용 날짜 객체 생성 (이전 달 날짜인 경우 달을 -1 처리)
                                const targetDate = new Date(year, currentDate.getMonth() + (isCurrentMonth ? 0 : -1), displayDay);
                                const dateKey = `${targetDate.getFullYear()}-${String(targetDate.getMonth() + 1).padStart(2, '0')}-${String(targetDate.getDate()).padStart(2, '0')}`;
                                
                                const minutes = focusData[dateKey] || 0;
                                const heatClass = getHeatClass(minutes);
                                
                                // 오늘 날짜인지 확인
                                const today = new Date();
                                const isToday = today.toDateString() === targetDate.toDateString();

                                return (
                                    <div key={i} className={`day-cell ${heatClass} ${isToday ? 'day-today' : ''} ${!isCurrentMonth ? 'opacity-40 saturate-0' : ''}`}>
                                        {minutes > 0 && (
                                            <div className="tooltip">
                                                {formatTime(minutes)}
                                            </div>
                                        )}
                                    </div>
                                )
                            })}
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
